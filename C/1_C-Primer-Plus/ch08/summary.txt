C에서는 서로 다른 시스템에 있는 서로 다른 파일 형식을 하나의 일관된 방식으로 처리하는 표준 입출력 패키지라 부르는 함수들을 제공한다.
getchar() 함수와 scanf() 함수가 이 패밀리에 속해 있다. 이 두 함수는 모두 파일의 끝을 탐지했을 때 EOF 값을 리턴한다.
Unix 계열 시스템들은 라인의 시작 위치에서 'Ctrl + D'를 입력함으로써, 파일의 끝 조건을 시뮬레이트한다.

(1) 파일, 스트림, 키보드 입력
컴퓨터 시스템마다 파일을 저장하고 처리하는 방식이 다르다.
예를 들어, 어떤 시스템은 하나의 개행 문자로 라인의 끝을 표시하는 반면, 다른 시스템은 캐리지 리턴 문자와 라인 피드 문자의 조합으로 라인의 끝을 표시한다.
또한, 어떤 시스템은 파일의 내용을 한 곳에 저장하고 그 파일에 대한 정보는 다른 곳에 저장하는 반면, 다른 시스템은 파일에 대한 정보를 그 파일 안에 저장한다.

C에서는 개념적으로 파일을 직접 다루지 않고 스트림(stream)을 다룬다.
스트림은 실제의 입력이나 출력이 맵핑된(mapped) 데이터의 이상화된 흐름이다.
이 것은, 서로 다른 특성을 가진 여러 종류의 입력들이, 좀 더 일관된 특성을 가진 스트림으로 표현된다는 것을 의미한다.

C에서는 보통의 파일들을 다루는 방식으로 입력 장치와 출력 장치를 다룬다.
키보드와 디스플레이 장치가 모든 C 프로그램에 의해 자동으로 열리는 파일처럼 다루어진다.
예를 들어, 키보드 입력은 stdin 스트림으로 나타내고, 화면 출력은 stdout 스트림으로 나타낸다.

(2) 파일의 끝
컴퓨터의 운영체제는 각각의 파일이 어디에서 시작하고 어디에서 끝나는지 말해주는 어떤 방법이 필요하다.
파일의 끝을 탐지하는 탐지하는 한 가지 방법은, 끝을 표시하는 특별한 문자를 파일 안에 넣는 것이다.
또 다른 방법으로는, 운영체제가 파일의 크기에 대한 정보를 저장하는 것이다.

C에서는 운영체제가 어떻게 파일 끝을 실제로 탐지하느냐에 관계없이, 파일의 끝에 도달했을 때 getchar() 함수가 특별한 값을 리턴하게 함으로써 호환성있게 처리한다.
이 특별한 값의 이름이 EOF(End Of File)이다.

일반적으로 EOF는 stdio.h 파일에 -1로 정의되어 있다.
일반적으로 -1로 정의되어 있는 이유는, 표준 문자 집합(0~127) 및 확장 문자 집합(0~255)에 포함되지 않은 수치 값이기 때문이다.

키보드 입력으로 EOF 문자를 타이핑하려면, Unix 계열 시스템에서는 'Ctrl + D'를 입력하면 된다.

(3) 에코(echo) 프로그램
int	main(void)
{
	int	c;

	while ((c = getchar()) != EOF)
		putchar(c);
	return (0);
}

에코 프로그램은 사용자로부터 제공받은 입력을 화면에 복사한다.
에코 프로그램을 활용할만한 가능성은 3가지 정도 된다.
-. 파일을 입력으로 제공받을 수 있다면, 이 프로그램은 파일의 내용을 화면으로 출력할 수 있다.
-. 파일로 출력할 수 있다면, 이 프로그램은 키보드로부터 입력받은 내용을 파일에 저장시킬 수 있다.
-. 위의 2개 동작이 된다면, 파일로부터 입력받은 내용을 또 다른 파일에 출력시킬 수도 있다. 즉, 파일 복사가 가능할 것이다.

(4) 리다이렉션
프로그램이 파일을 다루는 방법은 2가지가 있다.
첫 번째 방법은 파일을 열고, 닫고, 읽고, 쓰는 등의 작업을 할 수 있는 특별한 함수들을 명시적으로 사용하는 것이다.
두 번째 방법은 키보드와 화면을 처리하도록 설계된 프로그램을 사용하되, 다른 채널을 사용하도록 입력과 출력을 리다이렉션(redirection) 하는 것이다.

많은 운영체제들은 리다이렉션을 지원한다.
리다이렉션을 사용하면, 입력과 출력을 위해 화면이나 키보드 대신에 파일을 사용할 수 있다. 다시 말해, stdin 또는 stdout 스트림을 파일로 재지정할 수 있다.

리다이렉션을 사용할 때 적용되는 규칙은 다음과 같다.
-. 리다이렉션 연산자는, 하나의 실행 프로그램을 하나의 데이터 파일에 연결한다. 즉, 파일끼리 연결하거나 프로그램끼리 연결하는 데에는 사용할 수 없다.
-. 입력을 하나 이상의 파일로부터 받아들일 수 없으며, 마찬가지로 하나 이상의 파일로 출력을 리다이렉션 할 수 없다.

리다이렉션을 사용하는 예시는 다음과 같다.
-. 출력 : prog > file1
-. 입력 : prog < file2
-. 결합 : prog < file2 > file1

(5) 버퍼를 사용한 입력
사용자로부터 입력을 받을 때 버퍼(buffer)라는 임시 기억 장소에 모아서 저장했다가 활용하는 방식이 있다.
버퍼를 사용하면, 즉시 입력하는 방식에 비하여 처리 시간 감소 효과가 있고 사용자가 타이핑 오류가 발생했을 때 편집을 할 수 있는 이점도 있다.

버퍼를 사용한 입력 방식은 2가지로 구분지어볼 수 있다.
-. 완전 버퍼링 입력 : 일반적으로 파일 입력에서 활용하며, 버퍼가 가득찼을 때 버퍼가 비워진다.
-. 라인 버퍼링 입력 : 일반적으로 키도브 입력에서 활용하며, 개행 문자가 나타날 때마다 버퍼가 비워진다.

(6) 사용자 입력 처리 예제
일반적으로, 컴퓨터 시스템들은 라인 버퍼 입력을 사용한다.
이 것은 사용자가 'Enter' 키를 눌러야만 입력이 프로그램에 전달된다는 것을 의미한다.
또한, 'Enter' 키를 누르는 것은 프로그래밍에서 주의할 필요가 있는 하나의 개행 문자를 전달하기 때문에, 프로그램이 그 것을 처리해야 한다.

이를 해결하기 위한 해결책 중 하나는, while 루프를 사용하여 개행 문자까지 포함한 입력 라인의 나머지를 버리는 형태이다.
ex)	while ((response = getchar()) != 'y')	// 응답을 읽는다.
	{
		if (response == 'n')
			// code
		else
			printf("please enter 'y' or 'n'.\n");
		while (getchar() != '\n')	// 입력 라인의 나머지를 건너뛴다.
			continue ;
	}

만일, 프로그램이 문자 입력에 getchar() 함수를 사용하고, 수치 입력에 scanf() 함수를 사용한다면 의도대로 동작하지 않는다.
그 이유는, getchar()가 스페이스, 탭, 개행을 포함한 모든 문자를 읽는 반면에, scanf()는 수를 읽을 때 스페이스, 탭, 개행을 건너뛰기 때문이다.

이를 해결하기 위한 해결책 중 하나는, 위의 방법과 마찬가지로 scanf() 호출 후 while 루프를 사용하여 라인의 나머지를 버리는 형태이다.
ex) while ((c = getchar()) != '\n')
	{
		if (scanf("%d", &n) != 1)
			break ;
		while (getchar() != '\n')
			continue ;
	}
