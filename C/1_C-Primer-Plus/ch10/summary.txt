(1) 배열
배열(array)은 데이터형이 모두 동일한 원소들의 집합이다.
배열의 원소들은 메모리에 연속적으로 저장되고, 정수 인덱스를 사용하여 접근할 수 있다.

C에서, 배열의 첫 번째 원소는 인덱스가 0이다.
컴파일러는 인덱스들이 유효한지 검사하지 않는다.
잘못된 인덱스를 사용했을 때의 결과는 (C의 표준 방식으로 말해서) 정의되지 않는다.
따라서, 배열에 대해 유효한 범위의 인덱스를 사용하는 것은 전적으로 프로그래머의 책임이다.

C에서, 배열의 초기화 규칙은 다음과 같다.
-. 배열을 전혀 초기화하지 않으면, 쓰레기 값을 갖게 된다.
-. 배열을 일부분만 초기화하면, 나머지 원소들은 0 값을 갖게 된다.

배열을 처리하는 함수를 작성하면 편리하다.
그 것은 특정 작업을 특정 함수에 전담시켜 프로그램을 모듈화할 수 있도록 돕는다.
여기서 중요한 것은, 배열 이름을 실전달인자로 사용할 때, 전체 배열을 함수에 전달하는 것이 아니라는 사실이다. 단지, 배열의 주소만을 전달한다.
-. int sum(int *ar) <=> int sum(int ar[])

배열을 조작하는 함수는 어디에서 시작하고 끝나는지를 알아야 한다.
따라서, 일반적으로 배열을 처리하려는 함수는 배열의 주소와 배열의 원소 개수를 전달받는다.
그 이외에도, 배열을 알리는 또 다른 방법으로 두 개의 포인터를 전달하는 형태도 사용해볼 수 있다.
-. int sum(int *ar, int n) <=> int sum(int ar[], int n)
-. int sum(int *start, int *end)

배열을 조작하는 함수들은 주소를 전달받기 때문에, 원본 데이터의 무결성이 깨질 위험이 있다.
따라서, 만일 함수의 의도가 원본 배열을 변경하는 것이 아니라면, 그 배열을 나타내는 형식매개변수를 선언할 때 const 키워드를 사용하는 것이 좋다.
-. int sum(const int *ar, int n) <=> int sum(const int ar[], int n)

배열의 크기를 구할 때에는 아래와 같은 방법을 사용할 수 있다.
-. int n = sizeof(ar) / sizeof(ar[0]);

(2) 포인터
포인터의 기본 특성은 다음과 같다.
-. 포인터의 값은 그 것이 가리키는 객체의 주소이다.
-. 포인터에 * 연산자를 적용하면, 그 포인터가 가리키는 객체에 저장되어 있는 값을 얻는다.
-. 포인터에 1을 더하면, 그 포인터가 가리키는 객체의 바이트 수 크기만큼 포인터 값이 증가한다.

포인터를 사용할 때의 주의사항은 다음과 같다.
-. 초기화되지 않는 포인터의 내용을 역참조할 경우, 심각한 에러가 발생할 수 있다.
-. 배열을 처리함에 있어서 포인터 증감 연산자를 사용할 때, 포인터가 유효한 배열 원소를 가리키는지는 보장받지 못한다.

(3) 2차원 배열과 가변 길이 배열
2차원 배열을 처리하는 함수들을 작성한다면, 그 함수는 행과 열의 정보를 알아야 한다.
-. int display(int (*ar)[4], int rows) <=> int sum(int ar[][4], int rows)

가변 길이 배열(Variable-length Array)은 배열의 차원을 둘 다 전달인자로 전달할 수 있는 또 다른 신택스를 제공해주기도 한다.
그러나, VLA는 C11에서는 절대 기능이라기보다는 선택 기능이기 때문에, 이를 지원하지 않는 컴파일러들도 있다.
-. int display(int rows, int cols, int ar[rows][cols])
