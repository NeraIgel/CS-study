C 표준은 단지 C 언어만 서술하는 것이 아니다.
C 표준은 C 언어, C 전처리기, C 라이브러리로 이루어진 하나의 패키지를 서술한다.

(1) C 전처리기
전처리기(preprocessor)는 컴파일이 시작되기 전에 전치리기 지시자의 지시에 따라 소스 코드를 조절한다.
전처리기는 컴파일 과정, 대체할 문자열들의 목록, 컴파일할 코드들의 선택, 컴파일러 행동의 기타 측면 등을 사용자가 지정할 수 있게 한다.

컴파일러는 전처리 단계에 들어가기 전에, 프로그램이 몇 가지 번역 단계를 거치게 만든다.
-. 컴파일러는 소스 코드에 나타나는 문자들을 소스 문자 집합으로 매핑한다. 이 때 멀티바이트(multibyte) 문자와 삼중문자(trigraph)도 처리한다.
-. 컴파일러는 소스 코드에 나타나는 개행 문자가 있는 백슬래시를 없앰으로써, 물리적인 두 라인을 논리적인 한 라인으로 변환한다.
-. 컴파일러는 텍스트를 전처리 토큰(token)들의 시퀀스와, 화이트스페이스와 주석의 시퀀스로 분리한다.
-. 또한, 컴파일러에 따라서는 (개행 문자를 제외한) 화이트스페이스 문자들의 각 시퀀스를 스페이스 하나로 대체한다.

(2) #define 지시자
전처리기가 #define 지시자를 발견하면, 해당하는 매크로를 정의한다.
하나의 #define 라인(즉, 논리적인 라인)은 지시자를 제외하면 두 부분으로 이루어진다.
첫 번째 부분은 매크로(macro)라고 부르는 사용자가 선택한 약어이다. 두 번째 부분은 대체 리스트(replacement list) 또는 몸체(body)이다.

전처리기는 사용자가 작성한 프로그램에서 어떤 매크로를 만나면, 항상 그 것을 몸체로 대체한다.
매크로가 대체 리스트로 대체되는 과정을 매크로 확장(macro expansion)이라 한다.

기술적으로, 매크로의 몸체는 문자로 구성된 문자열이 아니라 토큰으로 구성된 문자열로 간주된다.
문자 문자열과 토큰 문자열은 몸체에 있는 여러 스페이스를 처리하는 방법에서 차이가 난다.

#define 매크로가 영향을 미치는 범위는 파일에서 자신이 정의된 위치에서부터 #undef 지시자에 의해 취소되는 위치까지 또는 파일의 끝까지다.
파일에서 #define의 위치는, 그 매크로가 헤더 파일을 통해 포함될 경우, #include 지시자의 위치에 의해 결정된다.

(3) #define 지시자의 활용
#define 지시자를 활용하여, 기호 상수들을 정의할 수 있다.
기호 상수들은 값에 의미 있는 이름을 줄 수 있고, 프로그램을 수정하기 쉬우며, 프로그램의 이식성을 높여 준다는 점에서 가치를 지닌다.
최근에 C가 지원하는 const 키워드는, 상수들을 만드는 좀 더 융통성 있는 방법을 제공한다.

#define 지시자에 전달인자를 사용함으로써, 함수처럼 보이고 함수처럼 행동하는, 함수 같은 매크로(function-like macro)를 만들 수도 있다.
그러나, 매크로 전달인자는 정확하게 함수 전달인자처럼 동작하지는 않기 때문에, 사용할 때 주의해야 한다.

일반 함수 대신에 매크로를 사용하는 것은 인라인 코드를 만들 수 있다는 측면에서, 프로그램의 실행 속도를 높일 수 있는 장점을 가지고 있다.
프로그램의 실행 속도를 높이기 위해 함수 대신 매크로를 사용하려면, 먼저 주목할 만한 차이가 있겠는지 검토해 보아야 한다.
대체로, 중첩된 루프 안에 있는 매크로는 실행 속도 개선의 좋은 후보감이다.

한편, C++에서 아이디어를 빌린 C99는 다른 접근법인 인라인 함수(inline function)를 추가했다.
표준에 의하면 내부 연계가 있는 함수는 인라인 함수가 될 수 있으며 인라인 함수에 대한 정의는 함수가 사용된 같은 파일 내에 있어야 한다.
그러므로, 인라인 함수는 static 저장 클래스 지정자와 함께 사용되며, 헤더 파일에는 실행 코드를 넣지 않는다는 규칙에서 예외가 된다.
인라인 함수는, 독립된 코드 블록이 할당되지 않기 때문에, 사용자는 일반적으로 그 것의 주소를 취할 수 없다.

(4) #include 지시자
전처리기가 #include 지시자를 발견하면, 그 뒤를 따르는 파일 이름을 찾아 그 파일의 내용을 현재 파일에 포함시킨다.

#include 지시자는 두 가지 형태가 있다.
Unix 시스템에서, 꺽쇠괄호(< >)는 전처리기에게 하나 또는 그 이상의 표준 시스템 디렉토리에서 그 파일을 찾으라고 지시한다.
큰따옴표(" ")는 현재 작업 디렉토리에서 그 파일을 찾으라고 지시한다. (또는 파일 이름에 지정된 디렉토리에서 찾으라고 지시한다.)

(5) 기타 전처리기 지시자
전처리기는 몇 가지 지시자들을 추가적으로 제공한다.
#undef 지시자는 그 이전에 이루어진 #define 정의를 취소한다.
#if, #ifdef, #ifndef, #else, #elif, #endif 지시자들을 사용하면 여러 코드 중에서 어느 코드를 컴파일할 것인지 지정할 수 있다.
#pragma 지시자를 사용하면, 소스 코드 안에 직접 컴파일러 지시 사항을 넣을 수 있다. 일반적으로, 각 컴파일러는 자신만의 프라그마 집합을 따로 가지고 있다.

#ifndef 지시자는 주로 한 파일이 여러 번 포함되는 것을 막는 데 사용된다.
즉, 헤더 파일에 다음과 같은 라인들을 설정할 수 있다.
-.	/* things.h */
	#ifndef THINGS_H
	# define THINGS_H
		/* 헤더 파일 내용 */
	#endif

표준 C 헤더 파일들은 중복 포함되는 것을 피하기 위해 #ifndef 테크닉을 사용한다.
일반적으로 소프트웨어 개발업체들은, 파일 이름을 식별자로 사용하되 대문자를 사용하고, 확장자의 마침표를 밑줄 문자로 대체하고, 밑줄 문자를 접두사와 접미사로 활용한다.
사용자도 비슷하게 할 수 있다. 그러나, 접두사로 밑줄 문자를 사용하는 것은 피해야 한다. 왜냐하면, 이 방법은 표준에 의해 예약된 것이기 때문이다.

(6) C 라이브러리
C 라이브러리(library)는 C 언어의 능력을 확장하고, 많은 프로그래밍 문제들에 대해 이미 완성된 솔루션을 제공한다.
공식적인 C 라이브러리가 처음부터 있었던 것은 아니다. 사실상의 표준은 Unix C에 기반을 두고 나중에 나타났다.
그 후, ANSI C 위원회가 공식적인 표준 라이브러리를 개발했다.

(7) 범용 유틸리티 라이브러리 - stdlib.h
범용 유틸리티 라이브러리에는 난수 발생 함수, 검색과 정렬 함수, 변환 함수, 메모리 관리 함수 등을 포함하여, 각종 함수들이 들어 있다.

exit() 함수는 프로그램 실행을 종료시킬 때 사용한다.
덧붙여, exit() 함수는 main()으로부터 리턴할 떄 자동으로 호출된다.

atexit() 함수는 exit() 함수가 호출되었을 때 호출할 함수들의 리스트에, 전달받은 함수를 등록하는 역할을 한다.
최종적으로 exit() 함수가 호출될 때, 마지막으로 추가된 함수가 맨 먼저 실행되는 방식으로, 리스트에 있는 함수들이 실행된다.

exit() 함수는 atexit()에 의해 지정된 함수들을 실행한 후, 자기 자신을 위한 마무리를 수행한다.
모든 출력 스트림들을 비우고, 열려 있는 모든 스트림들을 닫는다. 그리고, 표준 입출력 함수 tmpfile()의 호출에 의해 생성된 임시 파일들을 닫는다.
그러고 나서, exit()는 호스트 환경으로 제어를 리턴하는데, 가능하면 호스트 환경에 종료 상태를 보고한다. 이식성 있는 종료 상태를 위해 별도의 기호상수들을 제공한다.

(8) 확인 라이브러리 - assert.h
확인 라이브러리는, 프로그램을 디버깅 하는 것을 돕기 위해 설계되었다.

이 것은 assert()라는 이름의 매크로 하나로 구성되어 있다. 이 것은 전달인자로 정수 표현식을 사용한다.
표현식이 거짓으로 평가되면, assert() 매크로는 표준 에러 스트림에 에러 메시지를 기록하고, abort() 함수를 호출하여 프로그램을 종료한다.

assert()를 사용하는 방식은 디버깅 완료 후, 릴리즈 파일을 손쉽게 만들 수 있다는 장점을 가지고 있다.
다음과 같은 #define 지시자를 활용하여, 코드를 변경하지 않고도 assert() 매크로 사용 여부를 결정할 수 있는 매커니즘을 가지고 있다.
-. #define NDEBUG	// assert() 미사용

(9) 가변 전달인자 라이브러리 - stdarg.h
가변 전달인자 라이브러리는, printf()와 같이 가변 인자를 사용하는 함수를 위해 설계되었다.

가변 인자 함수를 구현하기 위하여, 다음과 같은 매크로들을 활용할 수 있다.
-. va_list	: 가변 인자 포인터 변수
-. va_start	: 가변 인자 포인터 변수 초기화 (마지막 필수 인자를 활용하여 가변 인자의 시작 주소를 계산한다)
-. va_end	: 가변 인자 포인터 변수 NULL 처리
-. va_arg	: 가변 인자 포인터 변수를 역참조 후, 다음 인자를 참조 (내부적으로는 바이트패딩 효과를 감안하여 _INTSIZEOF() 매크로를 사용한다)
-. va_copy	: 가변 인자 포인터 변수 복사 (현재 가변 인자의 위치를 저장하고자 할 때 활용한다)
