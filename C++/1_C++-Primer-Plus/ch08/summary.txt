C++는 C의 함수 기능을 확장시켰다.
C++는 C로부터 상속받지 않은 인라인 함수, 참조로 변수 전달하기, 디폴트 매개변수, 함수 오버로딩(다형), 함수 템플릿 등 새로운 기능을 가지고 있다.

(1) 인라인 함수
인라인 함수는 프로그램의 실행 속도를 높이기 위해 C++에 새로 보강된 것이다.
인라인 함수와 일반 함수의 가장 큰 차이는, C++ 컴파일러가 코드를 프로그램에 어떻게 결합하느냐에 있다.

일반 함수의 호출 흐름은 아래와 같다.
-. 프로그램이 함수 호출 명령에 도달했을 때, 그 함수 호출 명령 바로 다음에 있는 명령의 주소를 메모리에 저장하고, 스택에 매개변수를 복사한 후, 그 함수가 시작되는 메모리 위치로 점프한다.
-. 그런 다음 그 함수의 코드를 수행하고, 함수의 리턴 값을 레지스터에 복사한 후, 저장해 두었던 주소의 명령으로 돌아온다.

위의 과정들이 일반 함수 호출의 오버헤드이다.
인라인 함수에서는 컴파일된 함수 코드가 프로그램의 다른 코드 안에 직접 삽입된다.
인라인 코드를 이용하면 함수를 그 자리에서 처리하므로, 그 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 돌아올 필요가 없다.

인라인 함수를 작성하는 일반적인 관행은 함수 원형을 아예 생략하고, 원형이 놓일 자리에 함수 정의 전체(함수 머리와 함수 코드)를 놓는 것이다.
ex)	inline double	square(double x) { return x * x; }

(2) 참조 변수
참조 변수는 어떤 변수에 대한 대용 이름(즉, 별명)을 만들 수 있는 일종의 변장한 포인터이다.
참조 변수는 구조체와 클래스 객체를 처리하는 함수들에 형식 매개변수로 주로 사용된다.

참조 변수는 상수 포인터 변수와 같이, 선언할 때 반드시 초기화를 함께 해야 한다.
-.	int&	rodents = rats;
-.	int * const	pr = &rats;

일반적으로, 특정 데이터형에 대하여 참조로 선언된 식별자는 그 데이터형의 데이터만을 참조할 수 있다.
그러나, ostream에서 파생된 ofstream과 같이, 한 클래스가 다른 클래스로부터 파생되었을 때, 기초 데이터형에 대한 참조는 파생 데이터형도 참조할 수 있다.

(3) 참조 매개변수
C++에서 함수를 호출하는 방식은 3가지가 있다.
-.	swapr(wallet1, wallet2);	// 변수를 전달
-.	swapp(&wallet1, &wallet2);	// 변수의 주소를 전달
-.	swapv(wallet1, wallet2);	// 변수의 값을 전달

값으로 전달하는 방식(pass by value)은 호출 함수가 건네주는 값의 복사본을 가지고 작업한다.
참조로 전달하는 방식(pass by reference)은 호출 함수가 건네주는 어떤 변수의 대용 이름을 사용해서 실제 데이터의 원본을 가지고 작업한다.

C++는 실제 매개변수와 참조 매개변수가 일치하지 않을 때 임시 변수를 생성할 수 있다. 최근의 C++는 매개변수가 const 참조일 경우에만 이 것을 허용한다.
참조 매개변수가 const일 경우, 컴파일러는 다음과 같은 두 가지 상황에서 임시 변수를 생성한다.
-. 실제 매개변수가 올바른 데이터형이지만 lvalue가 아닐 때
-. 실제 매개변수가 잘못된 데이터형이지만 올바른 데이터형으로 변환할 수 있을 때

위와 같은 행동이 상수 참조인 경우에만 동작하는 것은 아래와 같은 상황이 있을 수 있기 때문이다.
-.	void	swapr(int& a, int& b);
-.	long	a = 3, b = 5;
	swapr(a, b);	// 컴파일러는 두 개의 int형 임시 변수를 만들고, 그 것들을 각각 초기화한 후 임시 변수의 내용을 서로 교환하려고 할 것이다. 그렇게 되면, 실제 값은 변경되지 않게 된다.

참조 매개변수를 가진 함수의 목적이 매개변수로 전달되는 변수를 변경하는 것이라면, 임시 변수의 생성은 그 목적을 방해한다.
이 것을 해결하는 방법은 이러한 상황에서는 임시 변수의 생성을 허용하지 않는 것이다. 최근의 C++는 그렇게 하고 있다.

임시 변수가 생성되면, C++는 그 익명 변수에 실제 매개변수의 값을 대입하고, 참조 매개변수가 그 익명 변수를 참조하게 한다.
임시 변수를 사용하면 함수가 값으로 전달하는 방식처럼 동작하므로, 원본 데이터를 보호할 수 있다. (const와 목적이 같다)
임시 변수는 그 함수가 좀 더 다양한 매개변수를 사용할 수 있도록 해 준다.

(4) 참조 리턴
C++의 함수는 참조나 포인터를 리턴하지 않는 이상, 값을 복사해서 리턴해준다.

값으로 리턴하는 방식(return by value)은 임시 장소에 값이 복사되고, 함수가 종료되면 리턴에 의해 그 값이 호출 함수로 다시 전달된다.
참조로 리턴하는 방식(return by reference)은 임시 장소에 대한 복사 과정이 생략되므로, 보다 효율적인 방법이 될 수 있다.

참조를 리턴할 때 가장 중요한 것은, 함수가 종료될 때 수명이 함께 끝나는 메모리 위치에 대한 참조를 리턴하지 않도록 조심해야 한다는 것이다.
이 문제를 피하는 가장 간단한 방법은, 함수에 매개변수로 전달된 참조를 리턴하는 것이며, 일반적으로는 상수 참조로 리턴하는 것이 좋다.

상수 참조로 리턴하면 아래와 같은 상황을 피할 수 있으며, 사용자는 일반적으로 함수 리턴 값이 rvalue일 것이라고 기대할 것이기 때문이다.
-.	const free_throws&	accumulate(free_throws& target, const free_throws& source);
-.	accumulate(dup, five) = four;	// 변경 가능한 lvalue로 사용할수 없다.

(5) 디폴트 매개변수
C++의 함수 원형은 매개변수에 대한 디폴트 값을 사용자가 정의할 수 있게 허용한다.

디폴트 매개변수는 함수 호출에서 실제 매개변수를 생략했을 경우에 실제 매개변수 대신 사용되는 값이다.
디폴트 매개변수는 매개변수 리스트의 오른쪽에서 왼쪽으로만 제공될 수 있다.

디폴트 매개변수는 클래스 설계 작업을 시작할 때, 프로그래머가 정의해야 하는 생성자, 메서드, 메서드 오버로딩의 수를 줄여주는 데 도움을 주는 도구이다.

(6) 함수 오버로딩
함수의 시그니처는 그 함수의 매개변수 리스트이다.
함수의 시그니처를 다르게 하면 같은 이름의 두 함수를 정의할 수 있다. 이 것을 함수 다형 혹은 함수 오버로딩이라 한다.

오버로딩 참조 매개변수는 다음과 같이 매치된다.
-.	void	staff(double &rs);		// 변경 가능한 lvalue와 매치된다.
-.	void	staff(const double &rcs);	// rvalue와 const lvalue와 매치된다.

-.	void	stove(double &r1);		// 변경 가능한 lvalue와 매치된다.
-.	void	stove(const double &r2);	// const lvalue와 매치된다.
-.	void	stove(double &&r3);		// rvalue와 매치된다.

함수 오버로딩은 서로 다른 데이터형을 대상으로 하지만 기본적으로는 같은 작업을 수행하는 함수들에만 사용하는 것이 바람직하다.
만일, 디폴트 매개변수를 사용하여 같은 목적을 수행할 수 있다면, 하나의 함수를 사용하는 것이 더 간단하다.

C++는 오버로딩된 함수들을 구분하기 위하여, 각각의 함수들에 비밀 증명을 발급한다.
C++ 컴파일러는 이름 맹글링(name mangling)이라는 기법을 사용하여, 원래 함수 이름들을 변형하고 각 함수들에 고유한 이름을 붙인다.
이름 맹글링은 함수의 시그니처 정보가 활용되며, 컴파일러마다 각기 다른 방법으로 수행된다. 이후 링크 과정에서는, 새롭게 생성된 이름들을 사용해서 오버로딩된 함수들을 쉽게 구별하여 연결시킨다.

(7) 함수 템플릿
함수 템플릿은 함수 오버로딩 작업을 자동화하는 것이다.
일반형과 특정 알고리즘을 사용하여 함수를 정의하면, 컴파일러가 프로그램이 사용하는 특정 매개변수의 데이터형에 알맞은 함수 정의를 생성해준다.

함수 템플릿은 다음과 같이 작성할 수 있다.
-.	template<typename T>
	void	swap(T& a, T& b)
	{
		T	temp;

		temp = a;
		a = b;
		b = temp;
	}

(8) 함수 템플릿 특수화
명시적 특수화(explicit specialization)라는 특수화된 함수 정의를, 필요한 코드와 함께 제공할 수 있다.
컴파일러가 함수 호출에 정확히 대응하는 특수화된 정의를 발견하면, 템플릿을 찾지 않고 그 정의를 사용한다.

명시적 특수화는 다음과 같이 정의할 수 있다.
-.	template<>
	void	swap(job& j1, job& j2)	// job형에 대한 명시적 특수화
	{
		double	t1;

		t1 = j1.salary;
		j1.salary = j2.salary;
		j2.salary = t1;
	}

(9) 함수 템플릿 구체화
컴파일러가 특정 데이터형에 맞는 함수 정의를 생성하기 위해 템플릿을 사용할 때, 그 결과를 템플릿의 구체화(instaniation)라 한다.
예를 들어, int형 i와 j가 있다면, swap(i, j) 함수 호출은, 컴파일러가 int형을 사용하는 swap() 함수를 구체화하게 만든다.
이러한 방식의 구체화를 암시적 구체화(implicit instaniation)라 한다.

처음에는 암시적 구체화를 사용하는 것이, 컴파일러가 템플릿으로부터 함수 정의를 생성하는 유일한 방법이었다.
지금은 C++가 명시적 구체화(explicit instaniation)도 허용한다. 이 것은 컴파일러가 swap<int>()와 같은 특정 구체화를 생성하도록 사용자가 직접 지시할 수 있다는 것을 의미한다.
-.	template<typename T> void	swap(T&, T&);	// 템플릿 원형
-.	template<> void	swap<job>(job&, job&);		// job형을 위한 명시적 특수화
-.	template void	swap<char><char&, char&);	// char형을 위한 명시적 구체화

컴파일러는 사용자가 호출하지 않는 타입에 대해서는 구체화하지 않는다.
만약, 특정 타입에 대한 템플릿 함수를 강제로 만들고 싶다면 이 때 명시적 구체화로 강제 생성을 지시할 수 있다.

명시적 구체화는 라이브러리를 배포할 때 활용할 수 있다.
함수 템플릿 정의문은 보통 헤더 파일에 작성하기 때문에 헤더 파일을 배포해서 사용하게끔 할 수도 있겠지만, 함수의 내용을 숨기고 싶다면 명시적 구체화를 고려할 수 있다.
함수의 내용을 공개하지 않고 라이브러리를 배포하고 싶을 때에는, 명시적 구체화로 자주 사용할만한 타입에 대해 일련의 함수 집합을 미리 생성해놓고 배포하여 사용자들이 사용하게끔 할 수 있다.
