C++에 내장된 기본 데이터형만으로는 프로그램의 복잡한 데이터를 처리할 수가 없다.
그렇기 때문에, C++는 복합 데이터형을 제공한다. 복합 데이터형은 기본 정수형과 부동 소수점형으로부터 만들어진다.
이들 복합 데이터형 중에서 가장 복잡한 것은 클래스이다. 그러나, C++는 C로부터 가져온 몇 가지 다른 복합형들도 제공한다.

(1) 배열
배열은 동일한 데이터형의 여러 개의 값을 하나의 데이터 객체 안에 저장할 수 있으며, 인덱스를 사용하여 배열 내의 각 원소에 접근할 수 있다.

배열은 타입 정보(T)와 크기 정보(N)를 가지고 있다.
따라서, 배열 이름에 sizeof 연산자를 적용하면 배열의 전체 크기를 얻을 수 있다.
그러나, 배열 이름이 수식에서 사용될 떄에는 암시적으로 포인터로 변환되어 크기 정보를 잃어버리기 때문에, 일반적으로는 배열 이름이 그 배열의 첫 번째 원소의 주소와 동등한 것으로 취급된다.

(2) 구조체
구조체는 데이터형이 다른 여러 개의 값을 하나의 데이터 객체 안에 저장할 수 있으며, 도트(.) 멤버 연산자를 사용하여 개별적인 멤버에 접근할 수 있다.
C 언어에서는 구조체 변수를 선언할 때 키워드 struct를 요구한다. 그러나, C++에서는 키워드 struct를 생략할 수 있다.

(3) 공용체
공용체는 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식이다.

(4) 열거체
열거체는 상호 관련이 있는 기호 상수들을 정의하는 용도로 사용할 수 있는 데이터 형식이다.
열거체는 대입 연산자만 허용되고, 정의하는데 사용한 열거자 값들만 대입할 수 있다.

열거자들은 정수형이며 자동으로 int 형으로 승급될 수 있다. 그러나, int 형이 자동으로 열거체로 변환되지는 않는다.
각 열거체는 값 범위를 가진다. 값 범위를 정의하는 것은 컴파일러가 열거체를 보관하기 위해 얼마만큼의 공간을 대입하느냐와 관계가 있다.

(5) 포인터
포인터는 주소를 저장하도록 설계된 변수이다. 포인터는 자신이 저장하고 있는 주소를 지시하고 있다.
포인터를 선언할 때에는 반드시 그 포인터가 어떤 데이터형의 객체를 지시하는지 함께 지정해야 한다.

(6) 문자열 입력
C++는 두 가지 방법으로 문자열을 처리할 수 있다.
첫 번째는 C로부터 유래한 C 스타일의 문자열 처리 방법이고, 두 번째는 string 클래스 라이브러리에 기반을 둔 또 다른 문자열 처리 방법이다.

cin 객체를 사용하여 배열에 C 스타일의 문자열을 입력받을 떄에는 아래와 같은 방법들을 사용할 수 있다.
-.	cin.operator>>(streambuf *) : 화이트스페이스가 있으면 그 위치에서 문자열이 끝난 것으로 간주하여, 하나의 단어만 읽어들이고 널 문자를 끝에 추가한다. 화이트스페이스는 남겨둔다.
-.	cin.getline(char *, streamsize) : 개행 문자를 포함하여 전체 입력 행을 읽어들이되, 개행 문자는 널 문자로 대체한다.
-.	cin.get(char *, streamsize) : 개행 문자는 남겨 두고 전체 입력 행을 읽어들이며, 널 문자를 끝에 추가한다.

cin.operator>>(streambuf *)와 cin.get(char *, streamsize) 멤버 함수는 개행 문자를 입력 버퍼에 남겨 두기 때문에, 아래와 같이 사용해야 연속된 행을 읽어들일 수 있다.
ex)	(std::cin >> year).get();
	std::cin.get(address, 80).get();
ex)	std::cin.get(name, ArSize).get();
	std::cin.get(dessert, ArSize).get();

cin.get(char *, streamsize) 함수는 cin.getline(char *, streamsize) 함수에 비해 사용이 불편하나, 입력 버퍼에 개행 문자가 남아있는지를 통해서 전체 입력 행을 읽어들였는지 확인하기 용이하다.
cin.get(char *, streamsize) 함수는 빈 행을 읽어들이면, failbit가 설정되고 입력이 중지된다. cin.getline(char *, streamsize) 함수는 입력 버퍼에 문자들이 남아 있으면, failbit가 설정된다.
cin failbit가 설정된 경우, cin.clear() 멤버 함수를 호출해야 입력을 복원할 수 있다.

ISO/ANSI C++ 표준은 string 클래스를 추가하여 C++ 라이브러리를 확장시켰다.
그래서 이제는 문자열을 저장하는데 문자 배열을 사용하는 대신에, string 객체를 사용할 수 있다.
string 객체들은 문자열을 저장하는 데 꼭 알맞은 크기로 자동으로 조절되고, 대입 연산자를 사용하여 문자열을 복사할 수 있다.

string 객체에 대한 입출력 문법은 C 스타일 문자열과 유사하나, 한 행을 읽어들일 때에는 조금 다른 문법을 사용한다.
왜냐하면, istream 클래스는 string 클래스가 추가되기 전부터 C++에 포함되어 있었기 때문에, string 형을 인식하지 못한다.
그러므로, getline(istream&, string&) 함수는 비멤버 함수로 정의하였으며, operator>>(istream&, string&) 함수는 string 클래스에 대한 프렌드 함수로 정의하였다.
ex)	std::string	str;
	std::getline(std::cin, str);
ex)	std::string	str;
	std::cin >> str;

(7) 동적 할당
C++에서는 new 연산자와 delete 연산자를 사용하여 동적으로 메모리를 할당하고 해제할 수 있다.
ex)	std::string	*ps = new std::string;
	delete ps;
ex)	std::string	*stringArray = new std::string[100];
	delete [] stringArray;	// 대괄호 []가 사용되었기 때문에 첫 번째 원소가 해제되는 것이 아니라 배열 전체가 해제된다.
