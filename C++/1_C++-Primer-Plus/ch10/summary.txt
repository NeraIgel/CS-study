객체 지향 프로그래밍(OOP)은 프로그램 설계 방법의 하나이다.
C++는 C를 개선하여, 객체 지향 프로그래밍을 쉽게 구현할 수 있도록 만든 프로그래밍 언어이다.

다음은 객체 지향 프로그래밍의 가장 중요한 기능들이다.
-. 추상화(abstraction)
-. 캡슐화(encapsulation)와 데이터 은닉(data hiding)
-. 다형(polymorphism)
-. 상속(inheritance)
-. 코드의 재활용(reusability of code)

(1) 클래스
프로그래밍 문제를 객체 지향적인 접근으로 해결하는 첫 단계는, 객체에 필요한 데이터와, 그 데이터를 다루는 방법에 대하여 서술하는 것이다.
추상화된 인터페이스를 서술한 후에는, 인터페이스와 데이터 저장 형태를 구현하는 것으로 나아간다.
C++에서는 추상화된 인터페이스를 구현하기 위하여 클래스를 설계한다.

클래스(class)는 추상화를 사용자 정의 데이터형으로 변환해 주는 C++ 도구이다.
클래스는 데이터 표현과 데이터를 조작하는 메서드들을 하나의 패키지 안에 결합한다.
일반적으로, private 데이터 멤버들이 정보를 저장하고, 메서드라 부르는 public 멤버 함수들이 유일한 데이터 접근 방법을 제공한다.

private 부분에 데이터를 넣어 캡슐화하는 것은 데이터의 무결성을 보호하기 위한 것으로, 데이터 은닉(data hiding)이라고 한다.
세부적인 구현들을 따로 결합하여 추상화와 분리하는 것을 캡슐화(encapsulation)라고 한다. 데이터 은닉(데이터를 클래스의 private 부분에 넣는 것)은 캡슐화의 한 예이다.

따라서 클래스의 사용은 추상화, 데이터 은닉, 캡슐화라는 객체 지향 프로그래밍(OOP)의 목표를 쉽게 구현할 수 있게 해 주는 C++의 방법이다.

(2) 클래스 설계
일반적으로, 클래스 설계의 서술은 두 부분으로 이루어진다.
-. 클래스 선언(class declaration) : 데이터 멤버와 public 인터페이스를 서술한다.
-. 클래스 메서드 정의(class method definitions) : 클래스 멤버 함수가 어떻게 구현되는지를 서술한다.

클래스 설계를 서술하는 첫 번째 단계는 클래스 선언을 제공하는 것이다.
클래스 선언은 구조체 선언과 모양이 비슷하다. 클래스 선언은 데이터 멤버와 함수 멤버를 가질 수 있다.
클래스 선언은 private 부분을 가진다. private 부분에 선언된 멤버들은 멤버 함수들을 통해서만 접근할 수 있다.
클래스 선언은 또한, public 부분을 가진다. public 부분에 선언된 멤버들은 클래스 객체를 사용하여 프로그램이 직접 접근할 수 있다.
일반적으로, 데이터 멤버들은 private 부분에 들어가고, 멤버 함수들은 public 부분에 들어간다. 그러므로, 클래스 선언의 일반적인 형식은 다음과 같다.
-.	class ClassName {
	public:
		// member function prototypes
	private:
		// data member declarations
	};

클래스 설계를 서술하는 두 번째 단계는 클래스 멤버 함수를 구현하는 것이다.
클래스 선언에 함수 원형 대신에 완전한 함수 정의를 넣을 수도 있다. 그러나, 일반적으로 매우 짧은 함수들은 제외하고, 함수 정의들을 따로 분리하여 제공한다.
그러한 경우에, 멤버 함수가 어느 클래스에 속하는지를 나타내기 위해 사용 범위 결정 연산자(::)를 사용한다. 클래스 멤버 함수 정의의 일반적인 함수 헤더는 다음과 같다.
-.	returnType	ClassName::methodName(argument-list)

(3) 클래스와 객체
클래스는 사용자 정의 데이터형이다.
C++는 사용자 정의 데이터형을 표준 데이터형과 최대한 비슷하게 만들려고 한다.
그러므로, 클래스 변수를 선언함으로써 객체를 생성할 수 있으며, 또한 객체를 매개변수로 전달할 수도 있고, 함수의 리턴값으로 사용할 수도 있다. 그리고, 한 객체를 같은 데이터형의 다른 객체에 대입할 수도 있다.

객체는 클래스의 구체적인 하나의 사례(instance)이다.
객체는 클래스 선언의 데이터 부분에 대한 사본을 하나씩 갖지만, 클래스 메서드들은 공유한다.
객체를 사용하여 멤버 함수를 호출한다는 말은, 다른 OOP 언어에서 메시지를 보낸다(sending a message)는 말과 같은 뜻이다.
그러므로, 두 개의 서로 다른 객체에 같은 메시지를 보낸다는 말은, 같은 메서드를 호출하여 그 것을 두 개의 서로 다른 객체에 적용한다는 말과 같은 것이다.
ex)	Stock	kate("Woof, Inc.", 100, 63);
	Stock	joe("Pryal Co.", 120, 30);

	kate.show();	// show() 멤버 함수는 kate 객체의 데이터를 사용한다.
	joe.show();	// show() 멤버 함수는 joe 객체의 데이터를 사용한다.

(4) 클래스 생성자와 소멸자
클래스를 사용할 때 일반적으로 제공해야 하는 생성자와 소멸자라는 표준 함수가 있다.
클래스 생성자 메서드를 제공하면, 객체들을 생성하면서 동시에 그들을 초기화할 수 있다.
클래스 소멸자 메서드를 제공하면, 객체의 수명이 다했을 때 프로그램이 소멸자 메서드를 실행한다.

클래스 생성자는 그 클래스와 같은 이름을 가진다.
클래스 생성자는 함수 오버로딩이 가능하므로, 시그니처가 다르면 여러 개의 생성자를 가질 수 있다.
클래스 생성자는 여러 가지 형식을 사용하여 호출할 수 있으며, 예를 들어 아래와 같이 생성자 원형이 주어지는 경우 다음 형식 중 어느 하나를 사용하여 객체를 초기화 할 수 있다.
ex)	Bozo::Bozo(int age);

	Bozo	dribble = Bozo(44);	// 제 1 형식
	Bozo	roon(66);		// 제 2 형식
	Bozo	tubby = 32;		// 매개변수가 하나인 생성자를 위한 특별 형식

디폴트 생성자는 매개변수가 없으며, 명시적으로 초기화하지 않고 객체를 생성할 때 사용한다.
사용자가 어떠한 생성자도 제공하지 않으면, 사용자를 대신하여 컴파일러가 디폴트 생성자를 정의한다.
그렇지 않을 경우에는 사용자 자신의 디폴트 생성자를 제공해야 한다. 사용자가 제공하는 디폴트 생성자는 어떠한 매개변수도 사용하지 않거나, 모든 매개변수에 디폴트 값을 사용해야 한다.
ex)	Bozo::Bozo();					// Bozo 클래스 디폴트 생성자의 원형
	Bistro::Bistro(const char *s = "Chez Zero");	// Bistro 클래스 디폴트 생성자의 원형

	Bozo	bubil;					// 디폴트 생성자를 사용한다.
	Bistro	*pb = new Bistro;			// 디폴트 생성자를 사용한다.

객체가 생성될 때 프로그램이 생성자를 호출하는 것처럼, 객체가 소멸할 때 프로그램은 소멸자를 호출한다.
소멸자는 클래스당 하나만 가질 수 있다. 소멸자는 리턴형을 갖지 않으며(void형도 안 된다.), 매개변수도 갖지 않는다.
소멸자의 이름은 클래스 이름 앞에 틸데(~)가 붙은 것이다. 예를 들어, Bozo 클래스의 소멸자는 다음과 같은 원형을 가진다.
ex)	Bozo::~Bozo();

(5) this 포인터
하나의 멤버 함수를 하나 이상의 객체에 적용하기 위해서, 그 메서드에 제2의 객체를 매개변수로 전달할 수 있다.
메서드가 그 것을 호출한 객체를 명시적으로 참조해야 한다면, this 포인터를 사용할 수 있다.
this 포인터는 호출한 객체의 주소로 설정된다. *this는 그 객체 자체의 대용 이름이다.

생성자와 소멸자를 포함한 각각의 멤버 함수는 하나의 this 포인터를 가진다.
멤버 함수의 매개변수 괄호 뒤에 const 한정자를 사용하면, this 포인터를 const로 한정한다. 그러한 경우에는, this 포인터를 사용하여 그 객체의 값을 변경할 수 없다.

(6) 객체 배열
객체 배열은 표준 데이터형의 배열을 선언하는 것과 완전히 동일한 방법으로 선언한다.
ex)	const int	STKS = 4;
	Stock		mystuff[STKS];	// 명시적으로 초기화하지 않은 클래스 객체들을 생성할 때, 디폴트 생성자가 호출된다.

객체 배열을 선언하면서 아래와 같이 배열 원소들을 초기화할 수도 있다.
ex)	const int	STKS = 4;
	Stock		stocks[STKS] = {
		Stock("NanoSmart", 12.5, 20),
		Stock("Boffo Objects", 200, 2.0),
		Stock("Monolithic Obelisks", 130, 3.25),
		Stock("Fleep Enterprises", 60, 6.5)
	};

객체들의 배열을 초기화하는 위와 같은 방식은 처음에 디폴트 생성자를 사용하여 배열의 원소들을 생성한다.
그런 다음 중괄호 안에 있는 생성자들이 임시 객체를 생성하고, 그 내용을 배월 원소에 복사한다.
그러므로, 클래스 객체들의 배열을 생성하려면 클래스가 디폴트 생성자를 가져야 한다.

(7) 클래스 사용 범위 상수
클래스 사용 범위를 가진 상수를 아래와 같은 방법들로 정의할 수 있다.
ex)	class Bakery {
	private:
		enum {_Months = 12};			// 열거체를 선언하는 것은, 클래스 데이터 멤버를 생성하지 않는다.
		double	_costs[_Months];
	};
ex)	class Bakery {
	private:
		static const int	_Months = 12;	// 하나의 정적 상수를 생성한다. 모든 Bakery 객체들이 하나의 _Months 상수를 공유한다.
		double			_costs[_Months];
	};
