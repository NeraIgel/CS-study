C++는 for, while, do while이라는 세 종류의 루프를 제공한다.
루프는 조건 검사 표현식이 true 또는 0이 아닌 값으로 평가되는 동안 동일한 구문들의 집합을 반복하여 수행한다. 조건 검사 표현식이 false 또는 0으로 평가되면 루프를 종료한다.

for 루프와 while 루프는 루프 몸체에 있는 구문들을 실행하기 전에 먼저 조건을 평가하는 진입 조건 루프이다.
반면에, do while 루프는 루프 몸체의 구문들을 먼저 실행한 후에 조건 검사 표현식을 평가한다.

(1) 관계 표현식
루프의 조건 검사 표현식으로는 두 개의 값을 비교하는 관계 표현식이 자주 사용된다.
관계 표현식은 6개의 관계 연산자 <, <=, ==, >=, >, != 중에서 어느 하나를 사용한다.
관계 표현식은 bool값 true 또는 false로 평가된다.

(2) for 루프
for 구문을 작성할 때 C++는 다음과 같은 융통성을 부여하였다.
for 구문의 초기화 부분에 변수를 선언할 수 있다.
-.	for (int i = 0; i < 5; ++i)

이러한 변수는 for 구문 안에서만 존재하고 for 루프를 벗어나면 소멸된다.
그러나, 구식 규칙을 따르는 일부 C++는 i를 루프 앞에서 선언된 것으로 인식하여 루프를 벗어난 후에도 변수를 삭제하지 않을 수도 있다.

(3) 증가 연산자(++)와 감소 연산자(--)
C++의 루프에서는 증가 연산자와 감소 연산자를 자주 사용한다.
증가 연산자와 감소 연산자는 둘 다 접두어(prefix) 방식과 접미어(postfix) 방식으로 사용할 수 있다.
접두어 방식과 접미어 방식은 피연산자에 가져오는 효과는 동일하지만 연산을 적용하는 시점이 다르다.

내장 데이터형에 대해서는 두 가지 방식 중 어느 방식을 사용하여도 수행 속도에 거의 차이가 없다.
그러나, 사용자 정의 데이터형에 대해서는 접두어 방식이 좀 더 효율적이므로, 접두어 방식을 사용하는 것이 좋다.
왜냐하면, 접미어 방식은 먼저 값의 복사본을 만들고, 복사본의 값을 증가(감소)시키고, 그 복사본을 리턴하는 방식으로 동작하기 때문이다.

(4) Range 기반의 for 루프(C++ 11)
C++11에는 Range 기반의 for 루프라고 불리는 새로운 형태가 추가되었다.
ex)	double	prices[5] = { 4.99, 10.99, 6.87, 7.99, 8.49 };
	for ( double x : prices )
		std::cout << x << std::endl;	// prices 배열의 모든 요소들의 값을 출력한다.
	for ( double& x : prices )
		x = x * 0.80;			// prices 배열의 모든 요소들의 값을 변경한다.

Range 기반 for 루프는 초기화 리스트에도 사용될 수 있다.
이러한 루프는 변수 템플릿 컨테이너 클래스들에서 많이 사용된다.
ex)	for ( int x : {3, 4, 2, 8, 6} )
		std::cout << x << " ";
	std::cout << std::endl;

(5) 문자 단위 입력
C++에서는 cin 객체를 사용하여 문자 단위로 입력을 읽어들일 때, 사용할 수 있는 몇 가지 방법을 제공한다.
-.	cin >> ch;	// 화이트스페이스는 무시하고, 입력 문자를 ch에 저장한다.
-.	cin.get(ch);	// 그 값이 무엇이든 간에 ch에 저장한다.
-.	ch = cin.get();	// 그 값이 무엇이든 간에 ch에 저장한다.

사용자로부터 입력 받은 문자의 개수를 카운트하고 싶다면, 아래와 같이 작성할 수 있다.
ex)	char	ch;
	int	count = 0;
	
	while (std::cin.get(ch))		// 입력이 성공했고 EOF를 만나지 않았으면 루프를 실행한다. 보다 객체 지향적인 접근 방식이다.
		++count;

ex)	int	ch;
	int	count = 0;

	while ((ch = std::cin.get()) != EOF)	// EOF를 만나지 않았으면 루프를 실행한다. cin.get() 방식은 stdio.h의 getchar()를 마이그레이션 하는 용도로 주로 사용한다.
		++count;

cin은 EOF를 탐지했을 때 두 개의 비트(eofbit와 failbit)를 1로 설정한다.
cin.eof() 멤버 함수를 호출하면 eofbit가 설정되어 있는지 알 수 있다.
cin.fail() 멤버 함수를 호출하면 eofbit 또는 failbit가 설정되어 있는지 알 수 있다.
따라서, 입력 시도 뒤에 cin.eof()와 cin.fail() 메소드를 호출해서 입력 값을 검사해야 한다.

cin.get(char) 방식은 리턴 값이 istream 클래스 객체이며, cin은 조건 검사 표현식에서 bool 형으로 변환되어 평가된다. 입력에 실패했거나 EOF를 만났으면 false로, 그렇지 않으면 true로 평가된다.
cin.get() 방식은 리턴 값이 int 형으로 된 문자 코드이며, 그 문자 코드를 iostream 파일에 정의 되어 있는 EOF와 비교하여 입력의 끝을 판별할 수 있다.
