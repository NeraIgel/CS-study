C++에 내장된 기본 데이터형은 두 그룹으로 나뉜다.
-. 정수형 그룹 : bool, char, signed char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long
-. 부동 소수점형 그룹 : float, double, long double

(1) 리터럴 상수의 데이터형
정수형 상수는 기본적으로 int 형으로 저장된다.
부동 소수점형 상수는 기본적으로 double 형으로 저장된다.

C와 C++ 초기 버전들은 문자 상수를 int 형으로 저장했었다.
그래서, 초기 버전에서는 cout << '$'; 구문이 문자를 출력하지 않고 '$'에 해당하는 아스키 코드 값을 출력했었다.
이런 이슈에 대응하기 위하여 cout.put() 이라는 멤버 함수가 만들어졌으며, cout.put('$'); 구문은 원하는대로 문자를 출력하였다.
그러나, C++ Release2.0 이후에, 모든 C++들은 문자 상수를 int 형이 아닌 char 형으로 저장한다. 그래서, 이제는 cout이 문자 상수를 바르게 처리할 수 있게 되었다.

(2) 문자 세트
때로는 프로그램이 8비트 바이트로 표현할 수 없는 문자 세트를 처리해야 하는 경우도 있다.
C++는 이를 위하여, char 형으로는 기본 문자 세트를 나타내고, wchar_t(wide character type)으로 확장 문자 세트를 나타낼 수 있도록 한다.
wchar_t 형은 시스템에서 사용되는 가장 큰 확장 문자 세트를 나타낼 수 있을 만큼의 충분한 비트 폭을 가진 정수형이다.

최근에는 유니코드에 대한 많은 경험들이 공유되면서 wchar_t 형만으로는 부족하다는 것이 많이 알려졌다.
특별한 경우에 문자열을 변환할 때 길이와 부호가 고정될 필요가 있는데, wchar_t 부호와 길이는 가변이기 때문에 문제가 발생할 수 있다.
그래서, C++11은 unsigned 16비트형인 char16_t와 unsigned 32비트형인 char32_t를 소개하고 있다.
wchar_t, char16_t, char32_t와 같이 _을 가지고 있는 형들은 정수형의 일종이지만, 시스템마다 다를 수 있다.

(3) bool 형
ANSI/ISO C++ 표준에는 bool이라는 새로운 데이터형이 (C++에 신규로) 추가되었다.
bool형 변수는 참이나 거짓 중 어느 한 가지 값만 가질 수 있다.

미리 정의된 true와 false는 참과 거짓을 나타내며, true와 false는 int 형인 1과 0으로 변환될 수 있다.
또한, 어떠한 수치 값이나 포인터 값도 하나의 bool 값으로 암시적으로 변환될 수 있다. 0이 아닌 값들은 true로, 0 값은 false로 변환된다.

(4) 산술 연산과 데이터형 변환
C++는 수치 데이터형에 대해 산술 연산-덧셈, 뺄셈, 곱셈, 나눗셈, 나머지셈-을 수행하는 연산자를 제공한다.
두 연산자가 하나의 피연산자에 걸려 있을 때에는 우선순위 규칙과 결합 방향 규칙을 적용하여 어느 연산을 먼저 수행할 것인지를 결정한다.

C++는 데이터형을 혼합하여 사용하면, 데이터형의 불일치를 해결하기 위해 다음과 같은 상황에서 자동으로 데이터형 변환을 수행한다.
-. 특정 데이터형의 변수에 다른 데이터형의 값을 대입했을 때
-. 수식에 데이터형을 혼합하여 사용햇을 때
-. 함수에 매개변수를 전달할 때

C++에서는 데이터형 변환 연산자를 사용하여 강제로 데이터형을 변환시킬 수 있다.
static_cast<> 연산자는 어떤 수치 데이터형을 다른 수치 데이터형으로 변환하는 데 사용할 수 있다.
-. static_cast<typeName> (value)	// value를 typeName 형으로 변환한다.

데이터형 변환에서 데이터의 실제값은 대부분 그대로 유지된다. 그러나, 부동 소수점형을 정수형으로 변환할 때에는 주의가 필요하다.

(5) 초기화
C++에서 사용하는 초기화 형식은 다음과 같다.
ex)	int	owls = 101;		// C style
ex)	int	wrens(432);		// C++ style
ex)	int	hamburgers{ 24 };	// C++11 style

C++11은 초기화하는 값을 보고 변수형을 추론할 수 있다. 그러기 위해 auto의 의미를 재정의하고 있다.
초기화 선언 시 데이터형을 쓰지 않고 auto를 사용할 수 있다.
ex)	auto	n = 100;		// n은 int 형
ex)	auto	x = 1.5;		// x는 double 형

자동으로 변수형을 추론하는 것은 STL(Standard Template Library)을 사용할 때와 같이 복잡한 변수형을 다룰 때 유용하다.
ex)	std::vector<double>	scores;
	auto pv = scores.begin();	// std::vector<double>::iterator pv = scores.begin(); 구문을 대신 간편하게 작성할 수 있다.
